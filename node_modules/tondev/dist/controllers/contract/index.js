"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = exports.contractRunExecutorCommand = exports.contractRunLocalCommand = exports.contractRunCommand = exports.contractTopUpCommand = exports.contractDeployCommand = exports.contractInfoCommand = void 0;
const appkit_1 = require("@tonclient/appkit");
const core_1 = require("@tonclient/core");
const accounts_1 = require("./accounts");
const run_1 = require("./run");
const giver_1 = require("../network/giver");
const registry_1 = require("../network/registry");
const utils_1 = require("../../core/utils");
const fileArg = {
    isArg: true,
    name: "file",
    title: "ABI file",
    type: "file",
    nameRegExp: /\.abi$/i,
};
const infoFileArg = {
    ...fileArg,
    defaultValue: "",
};
const networkOpt = {
    name: "network",
    alias: "n",
    type: "string",
    title: "Network name",
    defaultValue: "",
};
const signerOpt = {
    name: "signer",
    alias: "s",
    title: "Signer key name",
    type: "string",
    defaultValue: "",
};
const addressOpt = {
    name: "address",
    alias: "a",
    title: "Account address",
    type: "string",
    defaultValue: "",
};
const functionArg = {
    isArg: true,
    name: "function",
    title: "Function name",
    type: "string",
    defaultValue: "",
};
const inputOpt = {
    name: "input",
    alias: "i",
    title: "Function parameters as name:value,...",
    description: "Array values must be specified as [item,...]. " +
        "Spaces are not allowed. If value contains spaces or special symbols \"[],:\" " +
        "it must be enclosed in \"\" or ''",
    type: "string",
    defaultValue: "",
};
const dataOpt = {
    name: "data",
    alias: "d",
    title: "Deploying initial data as name:value,...",
    description: "This data is required to calculate the account address and to deploy contract.\n" +
        "Array values must be specified as [item,...]. " +
        "Spaces are not allowed. If value contains spaces or special symbols \"[],:\" " +
        "it must be enclosed in \"\" or ''",
    type: "string",
    defaultValue: "",
};
const valueOpt = {
    name: "value",
    alias: "v",
    title: "Deploying balance value in nano tokens",
    type: "string",
    defaultValue: "",
};
const preventUiOpt = {
    name: "prevent-ui",
    alias: "p",
    title: "Prevent user interaction",
    description: "Useful in shell scripting e.g. on server or in some automating to disable " +
        "waiting for the user input.\n" +
        "Instead tondev will abort with error.\n" +
        "For example when some parameters are missing in command line " +
        "then ton dev will prompt user to input values for missing parameters " +
        "(or fails if prevent-ui option is specified).",
    type: "boolean",
    defaultValue: "false",
};
const DEFAULT_TOPUP_VALUE = 10000000000;
exports.contractInfoCommand = {
    name: "info",
    alias: "i",
    title: "Prints contract summary",
    args: [
        infoFileArg,
        networkOpt,
        signerOpt,
        dataOpt,
        addressOpt,
    ],
    async run(terminal, args) {
        if (args.file === "" && args.address === "") {
            throw new Error("File argument or address option must be specified");
        }
        const account = await accounts_1.getAccount(terminal, args);
        const parsed = await account.getAccount();
        const accType = parsed.acc_type;
        if (account.contract.tvc) {
            const boc = account.client.boc;
            const codeHash = (await boc.get_boc_hash({
                boc: (await boc.get_code_from_tvc({ tvc: account.contract.tvc })).code,
            })).hash;
            terminal.log(`Code Hash: ${codeHash} (from TVC file)`);
        }
        if (accType === appkit_1.AccountType.nonExist) {
            terminal.log("Account:   Doesn't exist");
        }
        else {
            const token = BigInt(1000000000);
            const balance = BigInt(parsed.balance);
            let tokens = Number(balance / token) + Number(balance % token) / Number(token);
            const tokensString = tokens < 1 ? tokens.toString() : `â‰ˆ ${Math.round(tokens)}`;
            terminal.log(`Account:   ${parsed.acc_type_name}`);
            terminal.log(`Balance:   ${balance} (${tokensString} tokens)`);
            parsed.boc = utils_1.reduceBase64String(parsed.boc);
            parsed.code = utils_1.reduceBase64String(parsed.code);
            parsed.data = utils_1.reduceBase64String(parsed.data);
            terminal.log(`Details:   ${JSON.stringify(parsed, undefined, "    ")}`);
        }
        await account.free();
        account.client.close();
    },
};
exports.contractDeployCommand = {
    name: "deploy",
    alias: "d",
    title: "Deploy contract to network",
    args: [
        fileArg,
        networkOpt,
        signerOpt,
        functionArg,
        inputOpt,
        dataOpt,
        valueOpt,
        preventUiOpt,
    ],
    async run(terminal, args) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let account = await accounts_1.getAccount(terminal, args);
        const info = await account.getAccount();
        if (info.acc_type === appkit_1.AccountType.active) {
            throw new Error(`Account ${await account.getAddress()} already deployed.`);
        }
        const network = new registry_1.NetworkRegistry().get(args.network);
        const currentBalance = BigInt((_a = info.balance) !== null && _a !== void 0 ? _a : 0);
        const requiredBalance = (_d = (_b = utils_1.parseNumber(args.value)) !== null && _b !== void 0 ? _b : (_c = network.giver) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : DEFAULT_TOPUP_VALUE;
        if (currentBalance < BigInt(requiredBalance)) {
            const giverInfo = new registry_1.NetworkRegistry().get(args.network).giver;
            if (!giverInfo) {
                throw new Error(`Account ${await account.getAddress()} has low balance to deploy.\n` +
                    `You have to create an enough balance before deploying in two ways: \n` +
                    `sending some value to this address\n` +
                    `or setting up a giver for the network with \`tondev network giver\` command.`);
            }
            const giver = await giver_1.NetworkGiver.get(account.client, giverInfo);
            giver.value = requiredBalance;
            await giver.sendTo(await account.getAddress(), requiredBalance);
            await giver.account.free();
        }
        const dataParams = (_e = account.contract.abi.data) !== null && _e !== void 0 ? _e : [];
        if (dataParams.length > 0) {
            const initData = await run_1.resolveParams(terminal, `\nDeploying initial data:\n`, dataParams, (_f = args.data) !== null && _f !== void 0 ? _f : "", args.preventUi);
            await account.free();
            account = new appkit_1.Account(account.contract, {
                client: account.client,
                address: await account.getAddress(),
                signer: account.signer,
                initData,
            });
        }
        const initFunctionName = args.function.toLowerCase() === "none" ? "" : (args.function || "constructor");
        const initFunction = (_g = account.contract.abi.functions) === null || _g === void 0 ? void 0 : _g.find(x => x.name === initFunctionName);
        const initInput = await run_1.resolveParams(terminal, "\nParameters of constructor:\n", (_h = initFunction === null || initFunction === void 0 ? void 0 : initFunction.inputs) !== null && _h !== void 0 ? _h : [], args.input, args.preventUi);
        terminal.log("\nDeploying...");
        await account.deploy({
            initFunctionName: initFunction === null || initFunction === void 0 ? void 0 : initFunction.name,
            initInput,
        });
        terminal.log(`Contract has deployed at address: ${await account.getAddress()}`);
        await account.free();
        account.client.close();
        core_1.TonClient.default.close();
        process.exit(0);
    },
};
exports.contractTopUpCommand = {
    name: "topup",
    alias: "t",
    title: "Top up account from giver",
    args: [
        infoFileArg,
        addressOpt,
        networkOpt,
        signerOpt,
        dataOpt,
        valueOpt,
    ],
    async run(terminal, args) {
        var _a, _b;
        if (args.file === "" && args.address === "") {
            throw new Error("File argument or address option must be specified");
        }
        const account = await accounts_1.getAccount(terminal, args);
        const network = new registry_1.NetworkRegistry().get(args.network);
        const networkGiverInfo = network.giver;
        if (!networkGiverInfo) {
            throw new Error(`Missing giver for the network ${network.name}.\n` +
                `You have to set up a giver for this network with \`tondev network giver\` command.`);
        }
        const giver = await giver_1.NetworkGiver.get(account.client, networkGiverInfo);
        const value = (_b = (_a = utils_1.parseNumber(args.value)) !== null && _a !== void 0 ? _a : giver.value) !== null && _b !== void 0 ? _b : 1000000000;
        giver.value = value;
        await giver.sendTo(await account.getAddress(), value);
        terminal.log(`${giver.value} were sent to address ${await account.getAddress()}`);
        await giver.account.free();
        await account.free();
        account.client.close();
        core_1.TonClient.default.close();
        process.exit(0);
    },
};
exports.contractRunCommand = {
    name: "run",
    alias: "r",
    title: "Run contract deployed on the network",
    args: [
        fileArg,
        networkOpt,
        signerOpt,
        dataOpt,
        addressOpt,
        functionArg,
        inputOpt,
        preventUiOpt,
    ],
    async run(terminal, args) {
        const account = await accounts_1.getAccount(terminal, args);
        const { functionName, functionInput, } = await run_1.getRunParams(terminal, account, args);
        terminal.log("\nRunning...");
        const result = await account.run(functionName, functionInput);
        await run_1.logRunResult(terminal, result.decoded, result.transaction);
        await account.free();
        account.client.close();
        core_1.TonClient.default.close();
        process.exit(0);
    },
};
exports.contractRunLocalCommand = {
    name: "run-local",
    alias: "l",
    title: "Run contract locally on TVM",
    args: [
        fileArg,
        networkOpt,
        signerOpt,
        dataOpt,
        addressOpt,
        functionArg,
        inputOpt,
        preventUiOpt,
    ],
    async run(terminal, args) {
        const account = await accounts_1.getAccount(terminal, args);
        const { functionName, functionInput, } = await run_1.getRunParams(terminal, account, args);
        const accountWithoutSigner = new appkit_1.Account(account.contract, {
            client: account.client,
            address: await account.getAddress(),
        });
        const result = await accountWithoutSigner.runLocal(functionName, functionInput);
        await run_1.logRunResult(terminal, result.decoded, result.transaction);
        await account.free();
        await accountWithoutSigner.free();
        account.client.close();
        core_1.TonClient.default.close();
        process.exit(0);
    },
};
exports.contractRunExecutorCommand = {
    name: "run-executor",
    alias: "e",
    title: "Emulate transaction executor locally on TVM",
    args: [
        fileArg,
        networkOpt,
        signerOpt,
        dataOpt,
        addressOpt,
        functionArg,
        inputOpt,
        preventUiOpt,
    ],
    async run(terminal, args) {
        const account = await accounts_1.getAccount(terminal, args);
        const { functionName, functionInput, } = await run_1.getRunParams(terminal, account, args);
        const result = await account.runLocal(functionName, functionInput, {
            performAllChecks: true,
        });
        await run_1.logRunResult(terminal, result.decoded, result.transaction);
        await account.free();
        account.client.close();
        core_1.TonClient.default.close();
        process.exit(0);
    },
};
exports.Contract = {
    name: "contract",
    alias: "c",
    title: "Smart Contracts",
    commands: [
        exports.contractInfoCommand,
        exports.contractTopUpCommand,
        exports.contractDeployCommand,
        exports.contractRunCommand,
        exports.contractRunLocalCommand,
        exports.contractRunExecutorCommand,
    ],
};
//# sourceMappingURL=index.js.map