"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateConfig = exports.getInstanceInfo = exports.instanceContainerDef = exports.filterConfigInstances = exports.filterInstances = exports.setConfig = exports.getConfig = exports.getLatestVersion = exports.getVersions = exports.PORT_NONE = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const core_1 = require("../../core");
const utils_1 = require("../../core/utils");
const docker_1 = require("./docker");
const DEFAULT_INSTANCE_NAME = "default";
const DEFAULT_INSTANCE_PORT = 80;
const DOCKER_IMAGE_NAME = "tonlabs/local-node";
const DOCKER_CONTAINER_NAME_PREFIX = "tonlabs-tonos-se";
exports.PORT_NONE = -1;
async function getVersions() {
    const url = `https://registry.hub.docker.com/v2/repositories/${DOCKER_IMAGE_NAME}/tags/`;
    return (await utils_1.httpsGetJson(url)).results.map((x) => x.name).sort(utils_1.compareVersions);
}
exports.getVersions = getVersions;
async function getLatestVersion() {
    var _a;
    const versions = await getVersions();
    const version = versions.pop();
    if (version && version.toLowerCase() !== "latest") {
        return version;
    }
    return (_a = versions.pop()) !== null && _a !== void 0 ? _a : "";
}
exports.getLatestVersion = getLatestVersion;
function configPath() {
    return path.resolve(core_1.tondevHome(), "se", "config.json");
}
async function getConfig() {
    let config = null;
    try {
        if (fs.existsSync(configPath())) {
            config = JSON.parse(fs.readFileSync(configPath(), "utf8"));
        }
    }
    catch {
    }
    if (!config) {
        config = { instances: [] };
    }
    else if (!config.instances) {
        config.instances = [];
    }
    if (config.instances.length === 0) {
        config.instances.push({
            name: DEFAULT_INSTANCE_NAME,
            port: DEFAULT_INSTANCE_PORT,
            version: await getLatestVersion(),
        });
        await setConfig(config);
    }
    return config;
}
exports.getConfig = getConfig;
function setConfig(config) {
    const configDir = path.dirname(configPath());
    if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
    }
    fs.writeFileSync(configPath(), JSON.stringify(config, undefined, "    "), "utf8");
}
exports.setConfig = setConfig;
function filterInstances(instances, filter) {
    const names = filter.toLowerCase().split(",").map(x => x.trim()).filter(x => x !== "");
    if (names.includes("*")) {
        return instances;
    }
    const filtered = [];
    names.forEach(name => {
        const instance = instances.find(x => x.name.toLowerCase() === name);
        if (instance === undefined) {
            throw new Error(`Instance \"${name}\" is not found`);
        }
        filtered.push(instance);
    });
    return filtered;
}
exports.filterInstances = filterInstances;
async function filterConfigInstances(filter) {
    return filterInstances(await (await getConfig()).instances, filter);
}
exports.filterConfigInstances = filterConfigInstances;
function instanceContainerDef(instance) {
    const requiredImage = `${DOCKER_IMAGE_NAME}:${instance.version}`;
    const suffix = instance.name !== DEFAULT_INSTANCE_NAME ? `-${instance.name}` : '';
    const containerName = `${DOCKER_CONTAINER_NAME_PREFIX}-${utils_1.userIdentifier()}${suffix}`;
    return {
        requiredImage,
        containerName,
        createContainer(docker) {
            const ports = {
                '80/tcp': [
                    {
                        HostIp: '',
                        HostPort: `${instance.port}`,
                    },
                ],
            };
            if (instance.dbPort) {
                ports['8529/tcp'] = [
                    {
                        HostIp: '',
                        HostPort: `${instance.dbPort}`,
                    },
                ];
            }
            return docker.client.createContainer({
                name: containerName,
                // interactive: true,
                Image: requiredImage,
                Env: ['USER_AGREEMENT=yes'],
                HostConfig: {
                    PortBindings: ports,
                },
            });
        }
    };
}
exports.instanceContainerDef = instanceContainerDef;
function mapContainerName(name) {
    return name.startsWith('/') ? name.substr(1) : name;
}
async function getInstanceInfo(docker, instance) {
    var _a, _b;
    const def = instanceContainerDef(instance);
    const info = await docker.findContainerInfo(def.containerName);
    return {
        state: info ? info.State : "not installed",
        docker: {
            image: (_a = info === null || info === void 0 ? void 0 : info.Image) !== null && _a !== void 0 ? _a : def.requiredImage,
            container: (_b = info === null || info === void 0 ? void 0 : info.Names.map(mapContainerName).join(', ')) !== null && _b !== void 0 ? _b : def.containerName,
        }
    };
}
exports.getInstanceInfo = getInstanceInfo;
async function updateConfig(terminal, filter, updates) {
    const config = await getConfig();
    const docker = new docker_1.DevDocker();
    const instances = filterInstances(config.instances, filter);
    if (updates.version === undefined && updates.port === undefined && updates.dbPort === undefined) {
        throw new Error("There is nothing to set. You have to specify at least one config parameter. See command help.");
    }
    for (const instance of instances) {
        if (updates.version !== undefined) {
            instance.version = updates.version;
        }
        if (updates.port !== undefined) {
            instance.port = updates.port;
        }
        if (updates.dbPort === exports.PORT_NONE) {
            delete instance.dbPort;
        }
        else if (updates.dbPort !== undefined) {
            instance.dbPort = updates.dbPort;
        }
        const def = instanceContainerDef(instance);
        const info = await getInstanceInfo(docker, instance);
        await docker.shutdownContainer(terminal, def, docker_1.ContainerStatus.missing);
        await docker.startupContainer(terminal, def, info.state === "running" ? docker_1.ContainerStatus.running : docker_1.ContainerStatus.created);
    }
    setConfig(config);
}
exports.updateConfig = updateConfig;
//# sourceMappingURL=installer.js.map