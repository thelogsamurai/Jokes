"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Component = void 0;
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
const fs_1 = __importDefault(require("fs"));
class Component {
    constructor(home, name, options) {
        var _a, _b, _c, _d;
        this.home = home;
        this.name = name;
        this.isExecutable = (_a = options === null || options === void 0 ? void 0 : options.executable) !== null && _a !== void 0 ? _a : false;
        this.globally = (_b = options === null || options === void 0 ? void 0 : options.globally) !== null && _b !== void 0 ? _b : false;
        this.resolveVersionRegExp = (_c = options === null || options === void 0 ? void 0 : options.resolveVersionRegExp) !== null && _c !== void 0 ? _c : /Version:\s*([0-9.]+)/;
        this.targetName = (_d = options === null || options === void 0 ? void 0 : options.targetName) !== null && _d !== void 0 ? _d : name;
        if (this.isExecutable) {
            this.targetName = utils_1.executableName(this.targetName);
        }
        if (this.globally && !home) {
            this.path = this.targetName;
        }
        else {
            this.path = path_1.default.resolve(home, this.targetName);
        }
        if (options === null || options === void 0 ? void 0 : options.innerPath) {
            this.adjustedPath = path_1.default.resolve(home, options.innerPath);
        }
    }
    async run(terminal, workDir, args) {
        var _a;
        const out = await utils_1.run((_a = this.adjustedPath) !== null && _a !== void 0 ? _a : this.path, args, { cwd: workDir }, terminal);
        return out.replace(/\r?\n/g, "\r\n");
    }
    getSourceName(version) {
        return `${this.name}_${version.split(".").join("_")}_{p}.gz`;
    }
    async loadAvailableVersions() {
        return utils_1.loadBinaryVersions(this.name);
    }
    async resolveVersion(_downloadedVersion) {
        var _a, _b;
        if (fs_1.default.existsSync(this.path)) {
            const compilerOut = await this.run(utils_1.nullTerminal, process.cwd(), ["--version"]);
            return (_b = (_a = compilerOut.match(this.resolveVersionRegExp)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
        }
        return "";
    }
    async getCurrentVersion() {
        const infoPath = `${this.path}.json`;
        if (fs_1.default.existsSync(infoPath)) {
            try {
                const info = JSON.parse(fs_1.default.readFileSync(infoPath, "utf8"));
                if (info.version) {
                    return info.version;
                }
            }
            catch {
            }
        }
        return this.resolveVersion("");
    }
    async ensureVersion(terminal, force, requiredVersion) {
        const current = await this.getCurrentVersion();
        if (!force && current !== "" && !requiredVersion) {
            return false;
        }
        let version = (requiredVersion !== null && requiredVersion !== void 0 ? requiredVersion : "latest").toLowerCase();
        if (!force && version === current) {
            return false;
        }
        const available = await this.loadAvailableVersions();
        if (version === "latest") {
            version = available[0];
        }
        else {
            if (!available.includes(version)) {
                throw new Error(`Invalid ${this.name} version ${version}`);
            }
        }
        if (!force && version === current) {
            return false;
        }
        const sourceName = this.getSourceName(version);
        await utils_1.downloadFromBinaries(terminal, this.path, sourceName, {
            executable: this.isExecutable,
            adjustedPath: this.adjustedPath,
            globally: this.globally,
            version,
        });
        const info = {
            version: await this.resolveVersion(version),
        };
        fs_1.default.writeFileSync(`${this.path}.json`, JSON.stringify(info));
        return true;
    }
    static async ensureInstalledAll(terminal, components) {
        for (const component of Object.values(components)) {
            await component.ensureVersion(terminal, false);
        }
    }
    static async setVersions(terminal, force, components, versions) {
        let hasUpdates = false;
        for (const [name, component] of Object.entries(components)) {
            if (await component.ensureVersion(terminal, force, versions[name])) {
                hasUpdates = true;
            }
        }
        if (hasUpdates) {
            terminal.log(await this.getInfoAll(components));
        }
        else {
            terminal.log("All components already up to date.");
        }
    }
    static async updateAll(terminal, force, components) {
        const latest = {};
        for (const name of Object.keys(components)) {
            latest[name] = "latest";
        }
        await this.setVersions(terminal, force, components, latest);
    }
    static async getInfoAll(components) {
        const table = [["Component", "Version", "Available"]];
        for (const [name, component] of Object.entries(components)) {
            table.push([
                name,
                await component.getCurrentVersion(),
                (await component.loadAvailableVersions()).join(", "),
            ]);
        }
        return utils_1.formatTable(table, { headerSeparator: true });
    }
}
exports.Component = Component;
//# sourceMappingURL=component.js.map